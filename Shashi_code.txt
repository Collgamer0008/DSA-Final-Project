#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#define MAX_NODES 100
#define INF 99999

// Structure to represent a weighted edge
struct Edge
{
    int destination;
    int distance;
    char traffic;
};

// Structure to represent a graph node
struct Node
{
    int location;
    int housing_price;
    char type[20];
};

// Structure to represent the graph
struct Graph
{
    struct Node nodes[MAX_NODES];
    struct Edge edges[MAX_NODES][MAX_NODES];
    int num_nodes;
};

// Function to find the optimal location excluding already chosen optimal locations
int find_optimal_location_excluding(struct Graph *graph, int dist[MAX_NODES][MAX_NODES], int next[MAX_NODES][MAX_NODES], int excluded_locations[MAX_NODES])
{
    int min_cost = INF;
    int optimal_location = -1;

    for (int i = 0; i < graph->num_nodes; ++i)
    {
        if (strcmp(graph->nodes[i].type, "empty") == 0)
        {
            int already_chosen = 0;
            for (int j = 0; j < MAX_NODES; ++j)
            {
                if (excluded_locations[j] == i + 1)
                {
                    already_chosen = 1;
                    break;
                }
            }

            if (!already_chosen)
            {
                int current_cost = graph->nodes[i].housing_price;

                for (int j = 0; j < graph->num_nodes; ++j)
                {
                    current_cost += dist[i][j];
                    if (graph->edges[i][j].traffic == 'L' || graph->edges[i][j].traffic == 'l')
                    {
                        current_cost += 1;
                    }
                    else if (graph->edges[i][j].traffic == 'M' || graph->edges[i][j].traffic == 'm')
                    {
                        current_cost += 2;
                    }
                    else if (graph->edges[i][j].traffic == 'H' || graph->edges[i][j].traffic == 'h')
                    {
                        current_cost += 3;
                    }
                }

                if (current_cost < min_cost)
                {
                    min_cost = current_cost;
                    optimal_location = i + 1;
                }
            }
        }
    }

    return optimal_location;
}

// Function to add an edge to the graph
void add_edge(struct Graph *graph, int source, int destination, int distance, char traffic)
{
    graph->edges[source][destination].destination = destination;
    graph->edges[source][destination].distance = distance;
    graph->edges[source][destination].traffic = traffic;
}

// Function to input data for each node
void input_node_data(struct Graph *graph)
{
    printf("Enter the number of nodes: ");
    scanf("%d", &graph->num_nodes);

    for (int i = 0; i < graph->num_nodes; ++i)
    {
        printf("\nNode %d:\n", i + 1);
        graph->nodes[i].location = i + 1;

        printf("Enter housing price: ");
        scanf("%d", &graph->nodes[i].housing_price);

        printf("Enter node type (shop, park, gas station, mall, emptyland): ");
        scanf("%s", graph->nodes[i].type);
    }
}

// Function to input data for each edge (distance and traffic)
void input_edge_data(struct Graph *graph)
{
    char manual_input;
    printf("Do you want to manually input edges? (y/n): ");
    scanf(" %c", &manual_input);

    if (manual_input == 'y' || manual_input == 'Y')
    {
        int num_edges;
        printf("Enter the number of edges: ");
        scanf("%d", &num_edges);

        printf("Enter edges (source destination distance traffic) - one per line:\n");

        for (int i = 0; i < num_edges; ++i)
        {
            int source, destination, distance;
            char traffic[10];

            scanf("%d %d %d %s", &source, &destination, &distance, traffic);

            add_edge(graph, source - 1, destination - 1, distance, traffic[0]);
            add_edge(graph, destination - 1, source - 1, distance, traffic[0]); // Make the graph undirected
        }
    }
    else
    {
        for (int i = 0; i < graph->num_nodes; ++i)
        {
            for (int j = i + 1; j < graph->num_nodes; ++j)
            {
                printf("\nEnter distance between Node %d and Node %d: ", i + 1, j + 1);
                scanf("%d", &graph->edges[i][j].distance);
                graph->edges[j][i].distance = graph->edges[i][j].distance; // Make the graph undirected

                printf("Enter traffic between Node %d and Node %d (Low(L), Medium(M), High(H)): ", i + 1, j + 1);
                char traffic_input[10];
                scanf(" %s", traffic_input);

                if (strcmp(traffic_input, "L") == 0 || strcmp(traffic_input, "l") == 0)
                {
                    graph->edges[i][j].traffic = 'L';
                    graph->edges[j][i].traffic = 'L';
                }
                else if (strcmp(traffic_input, "M") == 0 || strcmp(traffic_input, "m") == 0)
                {
                    graph->edges[i][j].traffic = 'M';
                    graph->edges[j][i].traffic = 'M';
                }
                else if (strcmp(traffic_input, "H") == 0 || strcmp(traffic_input, "h") == 0)
                {
                    graph->edges[i][j].traffic = 'H';
                    graph->edges[j][i].traffic = 'H';
                }
                else
                {
                    printf("Invalid traffic input. Using default value 'L'.\n");
                    graph->edges[i][j].traffic = 'L';
                    graph->edges[j][i].traffic = 'L';
                }
            }
        }
    }
}

// Function to calculate the overall cost for each location
void calculate_overall_cost(struct Graph *graph)
{
    for (int i = 0; i < graph->num_nodes; ++i)
    {
        int overall_cost = graph->nodes[i].housing_price;

        for (int j = 0; j < graph->num_nodes; ++j)
        {
            overall_cost += graph->edges[i][j].distance;
            // Additional cost based on traffic
            if (graph->edges[i][j].traffic == 'L' || graph->edges[i][j].traffic == 'l')
            {
                overall_cost += 1; // Low traffic
            }
            else if (graph->edges[i][j].traffic == 'M' ||
                     graph->edges[i][j].traffic == 'm')
            {
                overall_cost += 2; // Medium traffic
            }
            else if (graph->edges[i][j].traffic == 'H' || graph->edges[i][j].traffic == 'h')
            {
                overall_cost += 3; // High traffic
            }
        }

        printf("Overall Cost for Node %d (%s): %d\n", i + 1, graph->nodes[i].type, overall_cost);
    }
}

// Function to run Floyd's algorithm and display shortest paths
void floyds_algorithm(struct Graph *graph, int dist[MAX_NODES][MAX_NODES], int next[MAX_NODES][MAX_NODES])
{
    // Initialize dist and next matrices
    for (int i = 0; i < graph->num_nodes; ++i)
    {
        for (int j = 0; j < graph->num_nodes; ++j)
        {
            dist[i][j] = graph->edges[i][j].distance;
            next[i][j] = (i != j && dist[i][j] < INF) ? j : -1;
        }
    }

    // Floyd's algorithm
    for (int k = 0; k < graph->num_nodes; ++k)
    {
        for (int i = 0; i < graph->num_nodes; ++i)
        {
            for (int j = 0; j < graph->num_nodes; ++j)
            {
                if (dist[i][j] > dist[i][k] + dist[k][j])
                {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    next[i][j] = next[i][k];
                }
            }
        }
    }
}

// Function to check if the graph is connected
bool is_graph_connected(struct Graph *graph, int visited[MAX_NODES], int start_node)
{
    // Depth-First Search (DFS) to check connectivity
    if (start_node < 0 || start_node >= graph->num_nodes)
    {
        return false;
    }

    visited[start_node] = 1;

    for (int i = 0; i < graph->num_nodes; ++i)
    {
        if (graph->edges[start_node][i].distance != INF && !visited[i])
        {
            is_graph_connected(graph, visited, i);
        }
    }

    for (int i = 0; i < graph->num_nodes; ++i)
    {
        if (!visited[i])
        {
            return false;
        }
    }

    return true;
}

// Function to find the optimal location based on the minimum overall cost
int find_optimal_location(struct Graph *graph, int dist[MAX_NODES][MAX_NODES], int next[MAX_NODES][MAX_NODES])
{
    int min_cost = INF;
    int optimal_location = -1;

    for (int i = 0; i < graph->num_nodes; ++i)
    {
        if (strcmp(graph->nodes[i].type, "empty") == 0)
        {
            int current_cost = graph->nodes[i].housing_price;

            for (int j = 0; j < graph->num_nodes; ++j)
            {
                current_cost += graph->edges[i][j].distance;
                // Additional cost based on traffic
                if (graph->edges[i][j].traffic == 'L' || graph->edges[i][j].traffic == 'l')
                {
                    current_cost += 1; // Low traffic
                }
                else if (graph->edges[i][j].traffic == 'M' || graph->edges[i][j].traffic == 'm')
                {
                    current_cost += 2; // Medium traffic
                }
                else if (graph->edges[i][j].traffic == 'H' || graph->edges[i][j].traffic == 'h')
                {
                    current_cost += 3; // High traffic
                }
            }

            if (current_cost < min_cost)
            {
                min_cost = current_cost;
                optimal_location = i + 1; // Adding 1 to convert to 1-indexing
            }
        }
    }

    return optimal_location;
}

// Function to display the shortest path from the optimal empty land to a specified location
void display_shortest_path(struct Graph *graph, int next[MAX_NODES][MAX_NODES], int optimal_empty_land, int destination)
{
    printf("Optimal Empty Land to Node %d (%s): ", destination, graph->nodes[destination - 1].type);
    int current_node = optimal_empty_land;
    while (next[current_node][destination] != destination)
    {
        printf("%d -> ", next[current_node][destination] + 1);
        current_node = next[current_node][destination];
    }
    printf("%d\n", destination);
}

// Function to display the menu and execute corresponding actions
void display_menu()
{
    printf("\nMenu:\n");
    printf("1. Find the best optimal location for the house\n");
    printf("2. Find the second-best optimal location for the house\n");
    printf("3. Find the third-best optimal location for the house\n");
    // Add more options as needed

    printf("Enter your choice (1, 2, 3, ...): ");
}

// Function to run Dijkstra's algorithm and display shortest paths
void dijkstras_algorithm(struct Graph *graph, int dist[MAX_NODES], int next[MAX_NODES], int start_node)
{
    bool visited[MAX_NODES] = {false};

    for (int i = 0; i < graph->num_nodes; ++i)
    {
        dist[i] = INF;
        next[i] = -1;
    }

    dist[start_node] = 0;

    for (int count = 0; count < graph->num_nodes - 1; ++count)
    {
        int u = -1;

        for (int i = 0; i < graph->num_nodes; ++i)
        {
            if (!visited[i] && (u == -1 || dist[i] < dist[u]))
                u = i;
        }

        visited[u] = true;

        for (int v = 0; v < graph->num_nodes; ++v)
        {
            int alt = dist[u] + graph->edges[u][v].distance;
            if (!visited[v] && graph->edges[u][v].distance != INF && alt < dist[v])
            {
                dist[v] = alt;
                next[v] = u;
            }
        }
    }
}

// Function to run Bellman-Ford algorithm and display shortest paths
void bellman_ford_algorithm(struct Graph *graph, int dist[MAX_NODES], int next[MAX_NODES], int start_node)
{
    for (int i = 0; i < graph->num_nodes; ++i)
    {
        dist[i] = INF;
        next[i] = -1;
    }

    dist[start_node] = 0;

    for (int count = 0; count < graph->num_nodes - 1; ++count)
    {
        for (int u = 0; u < graph->num_nodes; ++u)
        {
            for (int v = 0; v < graph->num_nodes; ++v)
            {
                int alt = dist[u] + graph->edges[u][v].distance;
                if (graph->edges[u][v].distance != INF && alt < dist[v])
                {
                    dist[v] = alt;
                    next[v] = u;
                }
            }
        }
    }
}
int calculate_overall_cost_for_location(struct Graph *graph, int dist[MAX_NODES][MAX_NODES], int next[MAX_NODES][MAX_NODES], int location)
{
    int overall_cost = graph->nodes[location].housing_price; // Fixed indexing

    for (int j = 0; j < graph->num_nodes; ++j)
    {
        overall_cost += dist[location][j];
        // Additional cost based on traffic
        if (graph->edges[location][j].traffic == 'L' || graph->edges[location][j].traffic == 'l')
        {
            overall_cost += 1; // Low traffic
        }
        else if (graph->edges[location][j].traffic == 'M' || graph->edges[location][j].traffic == 'm')
        {
            overall_cost += 2; // Medium traffic
        }
        else if (graph->edges[location][j].traffic == 'H' || graph->edges[location][j].traffic == 'h')
        {
            overall_cost += 3; // High traffic
        }
    }

    return overall_cost;
}

// Function to display the total distance from the optimal empty land to all locations
void display_total_distance_from_optimal(struct Graph *graph, int dist[MAX_NODES][MAX_NODES], int optimal_empty_land)
{
    printf("\nTotal Distance from Optimal Empty Land (Node %d) to All Locations:\n", optimal_empty_land + 1);
    for (int i = 0; i < graph->num_nodes; ++i)
    {
        if (i != optimal_empty_land)
        {
            display_shortest_path(graph, dist, optimal_empty_land, i + 1);
        }
    }
}

// Function to check if there are any empty lands in the graph
bool has_empty_lands(struct Graph *graph)
{
    for (int i = 0; i < graph->num_nodes; ++i)
    {
        if (strcmp(graph->nodes[i].type, "empty") == 0)
        {
            return true;
        }
    }
    return false;
}

// Function to sort the optimal locations based on their overall cost
void sort_optimal_locations(struct Graph *graph, int dist[MAX_NODES][MAX_NODES], int next[MAX_NODES][MAX_NODES], int *optimal_locations)
{
    // Sort the optimal locations based on their overall cost (bubble sort)
    for (int i = 0; i < 3; ++i)
    {
        for (int j = 0; j < 2 - i; ++j)
        {
            int location1 = optimal_locations[j];
            int location2 = optimal_locations[j + 1];

            int cost1 = calculate_overall_cost_for_location(graph, dist, next, location1);
            int cost2 = calculate_overall_cost_for_location(graph, dist, next, location2);

            if (cost1 > cost2)
            {
                // Swap locations
                int temp = optimal_locations[j];
                optimal_locations[j] = optimal_locations[j + 1];
                optimal_locations[j + 1] = temp;
            }
        }
    }
}

// Function to calculate the overall cost for a specific location
/*
The program provides the following functionalities:

Input Data: Allows the user to input data for each node, including housing prices and types. It also enables the user to input edge data, including distances and traffic conditions between nodes.

Connectivity Check: Verifies if the city graph is connected, ensuring that all locations are reachable.

Algorithm Choices: The user can choose between two algorithms for finding optimal locations:

Floyd's Algorithm: Computes the shortest paths between all pairs of nodes in the graph.
Bellman-Ford Algorithm: Finds the shortest paths from a specified starting node using dynamic programming.
Optimal Location Search: Finds the best, second-best, and third-best optimal locations for a house based on the minimum overall cost. The overall cost includes factors like housing prices, distances, and traffic conditions.

Sorting and Display: Sorts the optimal locations based on their overall cost and displays them, along with the total distance from each optimal location to other locations in the city.

Additional Features: The program incorporates functions to check for the existence of empty lands, display shortest paths, and calculate the overall cost for a specific location.

Overall, the program assists in decision-making for house placement by considering various factors such as housing prices, transportation, and connectivity within the city. The choice of algorithms allows for flexibility in finding optimal locations based on user preferences.

*/
// Updated main function
int main()
{
    struct Graph city_graph;
    input_node_data(&city_graph);

    // Check if the graph is connected
    int visited[MAX_NODES] = {0};
    if (!is_graph_connected(&city_graph, visited, 0))
    {
        printf("The city is not connected.\n");
        return 0;
    }

    input_edge_data(&city_graph);

    int dist[MAX_NODES][MAX_NODES];
    int next[MAX_NODES][MAX_NODES];
    floyds_algorithm(&city_graph, dist, next); // Initialize next array with Floyd's algorithm
    printf("\n");
    printf("\n");

    printf("For builders only :");
    printf("\n");

    calculate_overall_cost(&city_graph);

    int choice;
    int optimal_location;
    int optimal_locations[3] = {0}; // Array to store the optimal locations

    // Initialize the 'next' array before entering the loop
    for (int i = 0; i < MAX_NODES; ++i)
    {
        for (int j = 0; j < MAX_NODES; ++j)
        {
            next[i][j] = -1;
        }
    }

    int chosen_optimal_locations[MAX_NODES];
    for (int i = 0; i < MAX_NODES; ++i)
    {
        chosen_optimal_locations[i] = -1;
    }

    do
    {
        display_menu();
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
        case 2:
        case 3:
            printf("Choose algorithm for finding total distance:\n");
            printf("1. Floyd's Algorithm\n");
            printf("2. Bellman-Ford Algorithm\n");
            printf("Enter your choice (1, 2): ");
            int algorithm_choice;
            scanf("%d", &algorithm_choice);

            switch (algorithm_choice)
            {
            case 1:
                optimal_location = find_optimal_location(&city_graph, dist, next);
                chosen_optimal_locations[choice - 1] = optimal_location;
                break;
            case 2:
                printf("Enter the starting node for Bellman-Ford Algorithm: ");
                int bellman_ford_start_node;
                scanf("%d", &bellman_ford_start_node);
                bellman_ford_algorithm(&city_graph, dist[bellman_ford_start_node - 1], next[bellman_ford_start_node - 1], bellman_ford_start_node - 1);
                optimal_location = find_optimal_location(&city_graph, dist, next);
                chosen_optimal_locations[choice - 1] = optimal_location;
                break;
            default:
                printf("Invalid choice. Exiting...\n");
                return 0;
            }

            if (optimal_location == -1 || !has_empty_lands(&city_graph))
            {
                printf("\nThere are no empty lands.\n");
            }
            else
            {
                printf("\nThe best optimal location for the house is Node %d (empty land).\n", optimal_location);
                display_total_distance_from_optimal(&city_graph, dist, optimal_location - 1);
            }
            break;
        default:
            printf("Invalid choice. Exiting...\n");
            return 0;
        }

    } while (choice >= 1 && choice <= 3); // Continue the loop for valid choices

    // Store the chosen optimal locations in an array
    for (int i = 0; i < 3; ++i)
    {
        optimal_locations[i] = chosen_optimal_locations[i];
    }

    // Sort the optimal locations based on their overall cost
    sort_optimal_locations(&city_graph, dist, next, optimal_locations);

    // Display the sorted optimal locations

    printf("\nOptimal Locations Sorted by Overall Cost:\n");

    for (int i = 0; i < 3; ++i)
    {
        int location = optimal_locations[i];

        if (location != -1)
        {
            printf("%d. Node %d (Empty Land)\n", i + 1, location);
            display_total_distance_from_optimal(&city_graph, dist, location - 1);
        }
    }

    return 0;
}
